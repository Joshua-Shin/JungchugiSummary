정보처리기사 요약 정리
-----------
#### 시험개요
- 시험개요 <br> <img width="740" alt="스크린샷 2023-01-29 오후 4 56 51" src="https://user-images.githubusercontent.com/93418349/216806261-712d63eb-37fd-4c86-926e-a8edd7e87c5f.png">
- 14:10 삼육보건대학교H관 CBT2실
- 연습장 달라하면 주는듯 샤프 가져가자.
- 모르는 개념 나오면 유튜브에 "시나공 ㅇㅇㅇ" 이라 치면 잘 나옴

#### 1과목 소프트웨어 설계
- **UML** : 모델링 언어. 요구사항분석과 설계 단계에서 개발자간 의사소통을 위해 사용함. 그 중 유저케이스 다이어그램을 많이 사용.
- 유저케이스 : 구현할 기능, 서비스를 나타냄. 
- 유저케이스간에 점선과 실선으로 **확장관계, 포함관계, 일반화관계**를 표시함.
- ~~일반화관계: 트랜잭션 // 예금, 계좌조회, 인출~~
- ~~포함관계 : 사용자인증 // 시스템 가동, 시스템 종료~~
- ~~확장관계 : 글 작성 // 게시글에 그림 첨부~~
- 순차 다이어그램 : 동적임
- 메시지 지향 미들웨어 : 비동기형.
- 비동기형 : 시험지 풀고 체점 하는 방식처럼 주고 받는거.
- 동기형 : 동시에 일어나는.
- 익스트림 프로그래밍 : 애자일 방법론
- 비기능적 요구사항 : 성능, 보안, 품질, 안정..
- 미들웨어 : 클라이언트와 서버 간의 통신을 담당하는 시스템 소프트웨어, 운영체제와 애플리케이션 사이에서 **중간 매개** 역할도.
- 컴포넌트 : 재사용이 가능한 각각의 독립된 **모듈**
- OUI : Organic User Interface. 모든 사물과 사용자 간의 상호작용을 위한 인터페이스
- 액터 : 시스템과 상호작용하는 모든것(사람, 기계, 시스템 등)
- 디자인 패턴 
  - 객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들을 피하기 위해 사용되는 패턴.
  - 생성패턴 : 팩토리, 빌더, 싱글톤, 프로토타입 <br> <img width="640" alt="스크린샷 2023-02-05 오후 4 07 09" src="https://user-images.githubusercontent.com/93418349/216806348-a1c0c417-f2de-457d-a856-19770d1a16e7.png">
- 하향식 vs 상향식 <br> <img width="634" alt="스크린샷 2023-02-06 오후 7 29 03" src="https://user-images.githubusercontent.com/93418349/216948498-90a40f7a-22de-4e91-a7b9-829d9476e301.png">
  - 하향식 설계에서 레벨이 낮은 데이터 구조의 세부 사항은 설계초기 단계에서 필요
  - 기존 컴포넌트들을 조합하여 시스템을 개발하는 경우에는 상향식이 적합
  - 시스템 명세가 명확한 경우와 모든 것을 새로 개발하는 작업에는 하향식이 적합
  - 테스트 드라이버 : 필요한 데이터를 인자를 통하여 넘겨주고, 테스트가 완료된 후 그 결과 값을 받는 역할을 하는 가상의 상위 모듈
  - 테스트 스텁(stub) : a test stub replaces a component during testing to provide controlled and predictable responses.
- 자료 흐름도 <br> <img width="476" alt="스크린샷 2023-02-06 오후 7 33 14" src="https://user-images.githubusercontent.com/93418349/216949363-b45ddba1-deb4-415b-b387-7aa9dff6ddfd.png">
- 목업 vs 프로토타입 : 목업은 실제 작동 안되는거야. 진짜 그냥 시각적인 모형.
- 클래스 설계 원칙 <br> <img width="684" alt="스크린샷 2023-02-06 오후 7 42 59" src="https://user-images.githubusercontent.com/93418349/216951396-409dc329-7eca-4d9c-9eff-4174bda0900e.png">
- 아키텍처 설계과정 : 설계 목표 설정 -> 시스템 타입 결정 -> 아키텍쳐 패턴 적용 (스타일 적용 및 커스터마이즈) -> 서브시스템의 기능, 인터페이스 동작 작성 -> 아키텍처 설계 검토
- 객체지향 분석 기법 중 럼바우 방법 <br> <img width="630" alt="스크린샷 2023-02-06 오후 7 51 17" src="https://user-images.githubusercontent.com/93418349/216953125-a34908ba-be92-48f6-ad87-29da8c69f151.png"> <br> 객 동 기
  - 객체모델링 = 객체 다이어그램
  - 동적모델링 = 상태 다이어그램
  - 기능 모델링 = 자료흐름도
  - 객2, 동상, 기자
- FEP : Front-End Processor. 입력되는 데이터를 컴퓨터의 프로세서가 처리하기 전에 미리 처리하여 프로세서가 차지하는 시간을 줄여주는 프로그램이나 하드웨어
- 다형성 : 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미


#### 2과목 소프트웨어 개발
- 소프트웨어 품질 목표
  - 이식성(Portability): 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 능력
  - 효율성(Efficiency): 최소의 작업으로 요구되는 기능을 수행하는 정도
  - 사용 용이성(Usability): 소프트웨어를 쉽게 사용할 수 있는 정도
  - 정확성(Correctness): 사용자의 요구사항을 충족시키는 정도
- 워크스루 : 요구사항 명세서 작성자를 포함하여 **사전** 검토한 후에 짧은 검토 회의를 통해 결함을 발견
- 인스펙션 : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견
- 소프트웨어 버전 관리 도구 RCS(revision control system) : 다수의 사용자가 동시에 수정을 할 수 없도록 파일 잠금 방식으로 버전을 관리하는 도구. 다른 방향으로 진행된 개발 결과를 합치거나 변경 내용을 추적 할 수 있다. CVS와의 차이점은 소스파일의 수정을 한 사람만으로 제한한다.
- 블랙박스 테스트 : 프로그램 구조를 고려하지 않는 테스트. 반대는 
- 화이트박스 테스트 : 흐름, 구조, 이런걸 테스트
- 블랙박스 vs 화이트박스 <br> <img width="251" alt="스크린샷 2023-02-06 오후 8 36 38" src="https://user-images.githubusercontent.com/93418349/216961668-3be4c0cb-b5bc-4691-9e8c-16ef5f8cf7e2.png">
- IDE : 배포도 가능
- HttpUnit : 웹 브라우저 없이 **웹 사이트 테스트**를 수행하는데 사용되는 오픈 소스 소프트웨어 테스트 프레임워크
- 스택 : 인터럽트 처리, 서브루틴 호출 작업 등에 응용.
- NS Chart <br> <img width="284" alt="스크린샷 2023-02-06 오후 8 18 45" src="https://user-images.githubusercontent.com/93418349/216958498-37be20d6-9075-4673-9f37-33d062e4ac20.png">
  - 화살표나 goto 사용 안해, 읽기는 쉬운데 작성이 어려워
- 퀵정렬 : 피벗 사용
- 선택정렬 : 배열 내에서 최소값을 찾은 다음 정렬 되지 않은 맨 앞 값과 교환을 하며 정렬을 해 나아가는 방법
- 프로시저 : 일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합
- ISO/IEC 25000 <br> <img width="472" alt="스크린샷 2023-02-07 오후 6 58 30" src="https://user-images.githubusercontent.com/93418349/217212723-6dad5ff7-07b8-453c-bc2d-f1f90694071a.png">
- 트리
  - 2-3트리 : 트리의 높이가 균형을 이루며 내부노드의 차수가 2 또는 3인 균형 탐색트리입니다.
  - 2-3트리, avl, 레드-블랙 트리 모두 균형잡힌탐색트리
  - 그냥 이진탐색트리는 균형을 안잡기에 최악의 경우 검색 시간 복잡도가 O(n)
- 테스트 수행 도구
  - 자료 흐름도, 기능 테스트, 입력 도메인 분석, 랜덤 테스트
  - cf) 스텁과 드라이버는 통합 테스트 시 사용되는 것. 이와 달라
- 소프트웨어 테스트에서 검증(Verification)과 확인 (Validation)
  - 검증: 소프트웨어가 요구사항에 부합하게 구현되었음을 보장하는 활동. 개발자가 검증
  - 확인: 소프트웨어가 고객의 의도에 따라 구현되었음을 보장하는 활동. 사용자가 확인
  - 검증은 소프트웨어 개발 과정을 테스트하는 것이고, 확인은 소프트웨어 결과를 테스트 하는 것
- 소프트웨어 형상 관리(Software Configuration Management)
  - 형상 관리 절차: 형상 식별 -> 형상 통제 -> 형상 감사 -> 형상 기록/보고
  - 형상 식별: 형상 관리의 대상들을 구분하고 관리 목록의 번호를 정의하여 부여하는 과정
  - 형상 통제: 소프트웨어 형상 변경 제안을 검토, 현재 소프트웨어 기준선(Baseline)에 반영하도록 통제
  - 형상 감사: 형상 항목의 변경이 계획에 따라 제대로 이뤄졌는지를 검토/승인하는 것
  - 형상 기록/보고: 소프트웨어 개발 상태에 대한 보고서를 제공하는 것
- 디지털 저작권 관리(DRM) 구성요소
  - 콘텐츠 제공자: 콘텐츠를 제공하는 저작권자
  - 콘텐츠 분배자: 암호화된 콘텐츠 제공
  - 패키저: 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능
  - 보안 컨테이너: 원본을 안전하게 유통하기 위한 전자적 보안장치
  - DRM 컨트롤러: 배포된 콘텐츠의 이용 권한을 통제
  - 클리어링 하우스: 소비자와 유통업자 사이에 발생하는 거래에 대해 디지털 저작권 라이선싱을 중개하고 라이선스 발급을 수행하는 장소


#### 3과목 데이터베이스 구축
- 데이터베이스 정규형
  - 제1정규형 : 한칸에 하나의 데이터만 있는상태
  - 제2정규형 : 부분함수 종속이 있는 상태(= composite primary key가 있을때, 각 키가 결정 짓는 속성들이 다른 상태)를 다른 테이블로 나눠서 해결한 상태
  - 제3정규형 : 이행함수 종속이 있는 상해(key가 아닌 일반 필드가 다른 속성을 결정짓고 있는 상태)을 해결한 상태
  - BCNF : 모든 '결'정자가 후보키인 정규형
  - 4NF : '다'치종속이 성립하는 경우 테이블의 모든 속성이 함수적 종속 관계를 만족
  - 5NF : 모든 '조'인종속이 테이블의 후보키를 통해서만 성립되는 정규형
- 분산 데이터베이스의 목표
  - 위치 투명성 : 하드웨어와 소프트웨어의 물리적 위치를 사용자가 알 필요 없다.
  - 중복(복제) 투명성 : 사용자에게 통지할 필요 없이 시스템 안에 파일들과 지원들의 부가적인 복사를 자유롭게 할 수 있다.
  - 병행 투명성 : 다중 사용자들이 자원들을 자동으로 공유할 수 있다.
  - 장애 투명성 : 사용자들은 어느 위치의 시스템에 장애가 발생했는지 알 필요가 없다.
 - 트랜잭션 모델링 
  - 트랜잭션을 어떻게 수행하고 어떻게 데이터베이스를 변경하는지, 그리고 트랜잭션이 실패할 때 어떻게 복구할 수 있는지를 결정하는것
  - 데이터베이스 개념적 설계 단계에서 함
 - DCL : commit, rollback, grant, revoke
- 분산 데이터베이스의 구성 요소 <br> <img width="199" alt="스크린샷 2023-02-07 오후 7 25 42" src="https://user-images.githubusercontent.com/93418349/217219202-c6480b25-6b6b-4238-afbd-5d027b8b702c.png">
- 병행 제어
  - 병행 : 매우 빠르게 여러 트랜잭션 사이를 이동하면서 조금씩 처리를 수행하는 방식. 실제로는 한 번에 한 트랜잭션만 수행하지만, 마치 동시에 여러 트랜잭션을 수행하는 것처럼 보이도록 하는 것
  - 병행 제어 : 트랜잭션이 병행 수행될 때 트랜잭션이 데이터베이스의 일관성을 파괴하지 않고, 다른 트랜잭션에 영향을 주지 않도록 트랜잭션 간의 상호작용을 제어하는 것
  - 병행 제어의 목적
    - 데이터베이스의 일관성 유지
    - 데이터베이스 공유 최대화
    - 시스템 활용도 최대화
    - 사용자 응답 시간 최소화
    - 단위 시간당 트랜잭션 처리 건수 최대화
- 데이터 사전 : 시스템 데이터베이스, 시스템 카탈로그라
고도 함. 메타 데이터를 저장하고 있음. 사용자가 직접 갱신할 수는 없고, 다른 테이블에 변화를 주면 시스템이 자동으로 갱신함.
- 릴레이션 용어 <br> <img width="458" alt="스크린샷 2023-02-05 오후 6 05 40" src="https://user-images.githubusercontent.com/93418349/216810571-b0c1f9f2-244f-4e56-a9e6-c28b049a0c08.png">
- 모든 속성 값은 원자값을 가진다.
- 하나의 릴레이션에서 튜플에 순서는 없다.
- 트랜잭션의 상태 <br> <img width="691" alt="스크린샷 2023-02-05 오후 6 10 34" src="https://user-images.githubusercontent.com/93418349/216810752-c47e9095-1c83-402d-8e62-069ce9f2f1b2.png">
- 슈퍼키 : 유일성은 보장되는데, 최소성은 만족하지 못하는 키네.
- 차수(Degree) : 속성의 수
- 카디널리티(Cardinality) 튜플의 수 (기수)
- 관계해석 <br> <img width="196" alt="스크린샷 2023-02-07 오후 7 08 27" src="https://user-images.githubusercontent.com/93418349/217215215-45069862-9f10-4060-97d2-8fec0f7a7744.png">
- 함수적 종속 : 어떤 릴레이션 R이 있을때 X와 Y를 각각 속성의 부분집합이라고 가정해봅니다. 여기서 X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, Y는 X에 함수적 종속이라고 합니다. 이 경우 X를 결정자, Y를 종속자라고 합니다.
  - X -> Y 로 표시. X에 의해 Y가 결정된다. Y는 X에 종속 된다.
- 로킹 기법 : 하나의 트랜잭션이 데이터를 액세스하는 동안 다른 트랜잭션이 그데이터 항목을 액세스할 수 없도록 하는 병행 제어 기법. 같은 자원을 엑세스하는 다중 트랜잭션 환경에서 DB의 일관성과 무결성을 유지하기 위해 트랜젝션의 순차적 진행을 보장하는 직렬화 기법.
  - 로크 : 잠그는 데이터 객체
  - 로킹 단위 : 잠그는 단위. 지금 이 파일 내가 작업하고 있으니까 건들지마. 로킹단위가 파일이 되고, 아예 더 안전하게 폴더, 혹은 프로젝트 단취로 잠글수도 있겠지
  - 로킹 단위가 크면 -> 로크의 수가 적어진다. -> 제어 기법이 간단해 진다. -> 병행성이 감소한다.
  - 로킹 단위가 작으면 -> 로크의 수가 많아진다. -> 제어 하기 까다롭다. -> 병행성이 증가한다.
- 타임스탬프 기법 : 트랜젝션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임스탬프를 부여하여 부여된 시간에 따라 트랜젝션 작업을 수행하여 트랜잭션 간의 처리순서를 미리 정하는 기법
- 관계대수
  - 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어. 
  - 릴레이션 조작을 위한 연산의 집합으로 피연산자와 결과가 모두 릴레이션이다.
  - 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시한다.
  - 일반 집합 연산과 순수 관계 연산으로 구분된다.
    - 일반 집합 연산 : 합집합, 교집합, 차집합, 카티션 프로덕트
    - 순수 관계 연산 : select, project, join, division
- SSTF : shortest seek time first. 현재 헤드위치에서 가장 가까운 것부터


#### 4과목 프로그래밍 언어 활용
- strlen, strcpy, strcat, strcmp, strrev(s) : s를 거꾸로 변환
- IP 프로토콜
  - Header Length : IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시.
    - 32비트 워드 단위 : 1바이트가 8비트. 32비트면 4바이트. int 단위잖어. cpu마다 다르지만 보통 32비트를 1워드로 친대.
  - Packet Length : IP 헤더 및 데이터를 포함한 IP 패킷 전체 길이를 바이트 단위로 길이를 표시. 최대값은 2^16 -1
  - Time To Live : 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간
  - Version Number: IP 프로토콜의 버전번호
  - 주소를 지정하고, 경로를 설정하는 기능을 한다.
  - 체크섬 기능으로 헤더 체크섬만 제공한다
    - 헤더체크섬 : 전송 과정에서 발생할 수 있는 헤더 오류를 검출하는 기능
  - 패킷을 분할, 병합하는 기능을 수행
  - 비연결형 서비스를 제공
  - Best effort 원칙에 따른 전송 기능을 제공
- TCP 헤더
  - 순서번호(Sequence Number)는 전달하는 바이트마다 번호가 부여
  - 수신번호확인(Acknowledgement Number)은 상대편 호스트에서 받으려는 바이트의 번호를 정의한다.
  - 체크섬(Checksum)은 데이터를 포함한 세그먼트의 오류를 검사한다.
  - Window size는 16비트로 2^16 = 65535byte = 64KB
- 파이썬
  - if, elif, else. // else if 없음
  - 시퀀스 - 리스트 : 순서 있고, 가변
  - 시퀀스 - 튜플 : 순서 있고, 불변
  - 세트 - 세트 : 순서 없고, 중복 x
  - 맵 - 딕셔너리 : 순서 없고, key-value 쌍
  - 파이썬은 print()하면 자동으로 개행
  - ranger 함수
    - range(A) : 0부터 A-1까지의 정수 범위를 반환한다
    - ranger(A,B) : A부터 B-1까지의 정수 범위를 반환한다.
    - ranger(A,B,C) : A부터 B-1까지 C만큼의 간격으로 정수를 반환한다.
- RIP 라우팅 프로토콜 <br> <img width="641" alt="스크린샷 2023-02-05 오후 6 50 27" src="https://user-images.githubusercontent.com/93418349/216812209-669222c2-be97-4bdb-ade6-925613d3fd90.png">
- 각 라우터는 이웃 라우터들로부터 수신한 정보를 이용하여 라우팅 표를 갱신
- RR 스케줄링 : 라운드로빈, 선점 스케줄링 방식. 프로세스가 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당량이 끝나면 뒤로 보냄
- SJF : Shortest Job First, 최소 작업 우선
- HRN 스케줄링 : Highest Response-ratio Next. SJF를 보완하기 위해 나옴. 대기한 시간이 길어질수록 우선순위가 높아짐.
- MQ 스케줄링 : Multi level Queue. 다중레벨 스케줄링. 그 멀티큐로 구성해서 큐마다 다른 스케줄링으로 돌리는거.
- LRU 페이지 교체 알고리즘
  - Least Recently Used. 가장 오랫동안 사용하지 않은 페이지를 교체
  - 결함: 주기억장치의 페이지가 변동되는것
- 유닉스 
  - 서버용 
  - time sharing system을 위해 설계된 대화식 운영체제
  - 이식성. 호환성. C언어. 
  - Multi user, Multi tasking 모두 지원. 
  - 트리구조의 파일시스템
- UDP
  - 비연결형, 비신뢰성 전송 서비스를 제공
  - 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.
  - 수신된 데이터의 순서 재조정 기능을 지원하지 않는다.
  - 복구 기능을 제공하지 않는다.
  - 단순한 헤더 구조로 오버헤드가 적다.
  - TCP와 같이 트랜스포트(전송) 계층에 존재.
- 응집도와 결합도
  - 응집도: 하나의 모듈이 하나의 기능을 수행하는 요소들간의 연관성 척도. 
    - (강함) 기능적 응집도 > 순차적 > 교환적 > 절차적 > 시간적 > 논리적 > 우연적 응집도 (약함)
    - 기순교절시논
    - 시간적 응집도(Temporal Cohension) : 모듈 내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우의 응집도
    - Logical Cohension(논리적 응집도): 모듈 내 구성 요소들이 같은 범주에 속하는 기능끼리 묶인 경우(ex. 새글, 불러오기, 저장하기, 다른이름으로 저장하기)
    - Coincidental Cohension(우연적 응집도): 모듈 내 구성 요소들이 뚜렷한 관계없이 묶인 경우
    - Sequential Cohension(순차적 응집도): 모듈 내 구성 요소들이 이전의 명령어로부터 나온 출력결과를 그 다음 명령어의 입력자료로 사용하는 경우(ex. 총점과 평균의 관계)
  - 결합도 : 두 모듈간의 상호작용, 또는 의존도 정도를 나타내는 것 <br> <img width="630" alt="스크린샷 2023-02-05 오후 7 34 17" src="https://user-images.githubusercontent.com/93418349/216814037-97a7ce67-7163-4562-8bf2-a385a81f1cb7.png">
  - (강함) 내용 결합도 > 공통 > 외부 > 제어 > 스탬프 > 자료(데이터) 결합도 (낮음)
  - 데스제외공내
  - 응집도는 모듈 내 구성 요소들 간의 이야기이고, 결합도는 모듈과 모듈 사이의 이야기야.
  - 독립적인 모듈이 되기 위해서는 응집도가 강해야 한다. 결합도는 약해야 한다. 
- 사용자 수준에서 지원되는 스레드 : 커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어든다.
- IPv6 vs IPv4 <br> <img width="305" alt="스크린샷 2023-02-07 오후 8 15 36" src="https://user-images.githubusercontent.com/93418349/217230260-b4498f32-e7a3-4299-af0d-f056db4fdace.png">
- IPv4는 클래스 별로 네트워크와 호스트 주소의 길이가 다름
- C코드 <br> <img width="244" alt="스크린샷 2023-02-07 오후 8 23 22" src="https://user-images.githubusercontent.com/93418349/217231895-a0ab4430-497c-495d-aadc-f4ecfb764f70.png"> <br> <img width="392" alt="스크린샷 2023-02-07 오후 8 23 31" src="https://user-images.githubusercontent.com/93418349/217231917-b5bbe48c-d0da-4d74-b821-6f5fee08f10a.png">
- OSI 7계층 
  - 응표가 세트장 알바하는데 실수해서 네가 대신 물어줌. 응표세트네데물. 응용, 표현, 세션, 트랜스포트, 네트워크, 데이터링크, 물리.
  - 응용: http, dns, ftp, ssh
  - 트랜스포트 : tcp, udp
- ICMP(Internet Control Message Protocol) : TCP/IP 계층 구조에서 IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜
- 세마포어 : 임계 구역의 접근을 제어하는 상호배제 기법
- Java에서 매개변수로 배열 던지면 call by refe 인듯
- Ant = 아파치 재단에서 개발한 자바의 공식적인 빌드 도구
- Maven = 아파치 재단에서 개발, Ant 대안으로 개발되었음
- Gradle = Ant, Maven 의 보완으로 개발된 빌드 도구(안드로이드 스튜디오 주 빌드 도구)
- 쉘 : 반복적인 명령 프로그램을 만드는 프로그래밍 기능도 제공. 
- 프로세스와 메모리 관리는 커널이 함.
- 자동반복 요청방식(ARQ: Automatic Repeat reQuest) : 오류 제어에 사용
  - Stop-and-Wait ARQ(정지-대기 ARQ): 송신 측이 하나의 블록을 전송한 후 수신 측에서 에러의 발생을 점검한 다음, 에러 발생 유무 신호를 보내올 때까지 기다리는 방식
  - Go-Back-N ARQ: 여러 블록을 연속적으로 전송하고, 수신 측에서 부정 응답(NAK)을 보내오면 송신 측이 오류가 발생한 블록부터 모두 재 전송
  - Selective-Repeat ARQ(선택적 재전송 ARQ): 여러 블록을 연속적으로 전송하고, 수신측에서 부정 응답(NAK)을 보내오면 송신 측이 오류가 발생한 블록만을 재전송
  - Adaptive ARQ(적응적 ARQ): 전송 효율을 최대로 하기 위해서 데이터 블록의 길이를 채널의 상태에 따라 동적으로 변경하는 방식
- Q. 192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 4개의 Subnet으로 나누고 IP Subnet-zero를 적용했다. 이 때 Subnetting 된 네트워크 중 4번째 네트워크의 4번째 사용가능한 IP는 무엇인가?
- A. CIDR 표기법으로 ipv4 32비트중 앞 24비트가 네트워크ip, 뒤 8비트가 호스트ip가 됩니다.
  여기서 4개의 서브넷으로 나누려면 호스트ip의 앞쪽 비트를 가능한 적게 4개까지 나누어줘야 하는데요
  2진수에서 4개로 나누려면 2비트를 사용해야 하므로
  192.168.1.(00)000000 (0)
  192.168.1.(01)000000 (64)
  192.168.1.(10)000000 (128)
  192.168.1.(11)000000 (192)
  로 나눌 수 있습니다.
  여기서 IP subnet-zero를 적용했다는것은
  호스트ip가 전부 0인 192.168.1.0 도 사용하겠단것을 의미 합니다.
  즉 4번째 네트워크는 192.168.1.192가 되겠죠?
  단 각 서브넷에서 호스트ip가 전부 0인 주소와 전부 1인 주소는 다른 용도로 이미 예약이 되어있습니다.(0은 네트워크 자체의 주소, 1은 브로드캐스팅 주소)
  즉 여기서 4번째 사용가능한 ip는
  193,194,195,196←이게 되는거죠
- IP 주소 범위
  - A class : 0.0.0.0 ~ 127.255.255.255
  - B class : 128.0.0.0 ~ 191.255.255.255
  - C class : 192.0.0.0 ~ 223.255.255.255
  - D class : 224.0.0.0 ~ 239.255.255.255 // 멀티캐스트용
  - E class : 240.0.0.0 ~ 255.255.255.255 // 연구용
  - 128 -> 1000 0000
  - 192 -> 1100 0000
  - 224 -> 1110 0000
  - 240 -> 1111 0000
- 페이지 교체 알고리즘
  - OPT - Optimal : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
  - FIFO - First In First Out
  - LRU - Least Recently Used : 가장 오랫동안 사용되지 않은 페이지 교체
  - LFU - Least Frequently Used : 참조 횟수가 가장 작은 페이지 교체
  - MFU - Most Frequently used : 참조 횟수가 가장 많은 페이지 교체
  - NUR - Not Used Recently : 최근에 사용하지 않은 페이지 교체
- 프로세스
  - 디스패치 (Dispatch) : 준비 -> 실행
  - 할당시간초과 (Time Run Out) : 실행 -> 준비
  - 대기 (Block) : 실행 -> 대기
  - 깨움 (Wake Up) : 대기 -> 준비
  - PCB : 운영체제가 그 프로세스를 관리하는데 필요한 모든 정보를 유지하는 자료구조 테이블
  - 문맥교환 : CPU가 현재 실행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업
  - 스레드:  프로세스의 실행단위
- 파일 디스크립터(File Descriptor)
  - 파일마다 따로 있으며 시스템에 따라 다른 구조를 가질 수 있다.
  - 파일 시스템에서 관리하므로 사용자는 직접 참조할 수 없다.
  - 파일 이름, 위치, 파일 구조, 보조기억장치의 유형, (텍스트/이진/기계어/실행 파일 등)파일 유형, 시간, 액세스 등의 정보를 담고 있다.
  - 보조기억장치에 저장되어 있다가 파일이 개방(open)되면 주기억장치로 이동된다.



#### 5과목 정보시스템 구축 관리
- tcp wrapper : TCP 서버에서 네트워크 접근에 대한 필터링을 하는 것. 방화벽과 비슷한 역할
- 기기를 키오스크에 갖다댈때 작동하는 초고속 근접 무선 통신(NFC) 기술 : Zing 지이잉~
- Mesh Network : **그물** 모양의 네트워크 다른 국을 향하는 호출이 중계에 의하지 않고 직접 접속되는.
- 악성코드
  - Worm : 다른 컴퓨터의 취약점을 이용하여 스스로 전파하거나 메일로 전파되며 스스로를 증식하는 것. <br> <img width="640" alt="스크린샷 2023-02-06 오후 6 28 08" src="https://user-images.githubusercontent.com/93418349/216935229-341ab321-316a-429e-bf96-2550e97f2315.png">
- 공격기법 <br> <img width="641" alt="스크린샷 2023-02-06 오후 6 32 34" src="https://user-images.githubusercontent.com/93418349/216936158-2b5ae0aa-c97b-4751-9514-36236a21eac2.png">
- cocomo 모형 <br> <img width="400" alt="스크린샷 2023-02-06 오후 6 47 33" src="https://user-images.githubusercontent.com/93418349/216939432-49ca3a40-6b3d-4a53-8c9e-d4d8ebb55563.png">
- COCOMO 모델 : LOC( Line of Code ) 기반 비용 산정 방식
- Organic : 기관 내부의 중소 규모 sw대상, 5만 라인 이하 소프트웨어 개발에 적합
- Semi-Detached : Organic과 Embeded의 중간 단계, 30만 라인 이하
- Embeded : 초대형 규모의 시스템 소프트웨어를 대상, 30만 라인 이상의 sw개발에 적합
- spiral 개발순서: 계획및 정의 - 위험 분석 - 공학적 개발 - 고객 평가
- Authorization : 권한 부여
- Authentication : 인증
- SDN(Software Definded Networking) : 네트워크를 제어부, 데이터 전달부로 분리하여 네트워크 관리자가 보다 효율적으로 네트워크를 제어, 관리할 수 있는 기술
- SDS(Software Defined Storage) : 스토리지에 가상화를 적용, 소프트웨어로 전체 스토리지 자원을 관리하여 하나의 저장장치럼 사용할 수 있도록 하는 기법
- ~~Network Mapper : 네트워크 보안을 위한 유틸리티~~
- ~~AOE Network : 수행되는 작업의 각 단계를 정점과 간선으로 나타난 그래프~~
- PERT 차트 : 작업들 간의 상호 관련성, 결정경로, 경계시간, 자원할당 등을 제시하는 네트워크 도표
- 고가용성 솔루션 (HACMP: High Availability Cluster Multi Processing)
  - 각 시스템 간에 공유 디스크를 중심으로 **클러스터링**으로 엮어 다수의 시스템을 동시에 연결
  - 조직, 기업의 기간 업무 서버 등의 안정성을 높이기 위해 사용
  - 2개의 서버를 연결하는것으로 2개의 시스템이 각각 업무를 수행하도록 구현
- 스토리지 시스템
  - DAS : Direct-attached storage. 직접 연결 저장장치
  - NAS : Network Attached Storage 네트워크 결합 스토리지
- 블루투스 공격
  - 블루프린팅(BluePrinting) - 블루투스 공격 장치의 검색 활동을 의미
  - 블루버그: 블루투스 장비사이의 취약한 연결 관리를 악용한 공격
  - 블루스나프(블루스나핑): 블루투스의 취약점을 활용하여 장비의 파일에 접근하는 공격으로 OPP를 사용하여 정보를 열람
    - OPP(Obex Push Protocol)- 블루투스 장치끼리 인증 없이 정보를 간편하게 교환하기 위하여 개발됨
  - 블루재킹: 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼뜨리는 것
- Dos 공격
  - Ping of Death 공격 : 정상 크기보다 큰 ICMP 패킷을 작은 조각(Fragment)으로 쪼개어 공격 대상이 조각화 된 패킷을 처리하게 만드는 공격 방법이다.
  - Smurf 공격 : 브로드캐스트를 활용하여 공격 대상이 네트워크의 임의의 시스템에 패킷을 보내게 만드는 공격이다.
  - SYN Flooding : 존재하지 않는 클라이언트가 서버별로 한정된 접속 가능 공간에 접속한 것처럼 속여 다른 사용자가 서비스를 이용하지 못하게 하는 것이다.
  - Land 공격 : 패킷 전송 시 출발지 IP주소와 목적지 IP주소 값을 똑같이 만들어서 공격 대상에게 보내는 공격 방법이다
- Scrapy : Python 기반의 웹 크롤링(Web Crawling) 프레임워크
- 자원 삽입 : 자원을 조작 할 수 있는 문자열을 삽입하여 시스템이 보호하는 자원에 임의로 접근
- NTFS (New Technology File System)
    - FAT시스템을 대체하기 위해 개발된 윈도우 파일 시스템
    - 사용자마다 다른 보안 적용 가능 즉 보안이 FAT보다 뛰어남
    - 대용량 저장 가능 및 안정성이 뛰어남
- 로그파일 4대장
  - utmp : 현재 로그인한 사용자 상태 정보를 담고 있는 로그파일
  - wtmp : 성공한 로그인/로그아웃 정보를 담고 있는 로그파일
  - btmp : 실패한 로그인 정보를 담고 있는 로그 파일
  - last log : 마지막으로 성공한 로그인 정보를 담고 있는 로그파일
- DPI : OSI 7 Layer 전 계층의 프로토콜과 패킷 내부의 콘텐츠를 파악하여 침입 시도, 해킹 등을 탐지하고 트래픽을 조정하기 위한 패킷 분석 기술
- 침입탐지 시스템(IDS : Intrusion Detection System)
  - 이상탐지(Anomaly Detection) : Behavior, Statistical Detection로 불리며 평균적 시스템의 상태 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌. 잘 알려지지 않은 공격 탐지에 적합, 기존 패턴과 급격하게 다른 패턴을 발견하면 침입으로 판단.
  - 오용탐지(Misuse Detection) : Signature Base나 Knowledge Base로 불리며 미리 입력해둔 공격 패턴이 감지되면 이를 알려줌. 잘 알려진 시스템의 취약점을 공격하는 패턴의 침입을 탐지 (새로운 공격 패턴을 막기 어려움)
- 접근 통제
  - 강제접근통제(Mandatory Access Control): 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
  - 임의접근통제(Discretionary Access Control): 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
  - 역할 기반 접근 통제(Role Based Access Control) RBAC 
  - 사용자계정컨트롤(User Access Control): 프로그램에서 관리자 수준의 권한이 필요한 작업을 수행할 때 사용자에게 알려서 제어할 수 있도록 돕는 기능
  - 자료별 접근통제(Data-Label Access Control > Label-Based Access Control) : 개별 행, 열에 대해 쓰기 권한, 읽기 권한을 가졌는지를 명확하게 결정하는 제어 방식
- PaaS-TA : 국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼
- VLAN(Virtual Local Area Network) : 물리적 배치와 상관없이 논리적으로 LAN을 구성. Broadcast Domain을 구분할 수 있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과
- 암호화 알고리즘 
  - 양방향 vs 단방향
  - 양방향 : 개인키 vs 공개키
    - 개인키(= 대칭 암호 기법) : 동일한 키로 암호화 복호화, 단일키 암호 기법, 관리할 키의 수가 많고, 속도 빨라. 키 교환 필요
      - 블록방식: 블록단위로 암호화 ex) **DES, AES**, SEED, ARIA cf) DES : 64비트 암호화 알고리즘
      - 스트림 방식: 비트단위로 암호화 ex) LFSR, RC4 
    - 공개키(= 비대칭 암호 기법) : 암호화는 공개키로 복호화는 비밀(secret)키로. 관리해야하는 키의 수가 적음. 속도 느림. 키 교환 불필요. ex) **RSA**(소수 활용)
  - 단방향 : hash활용 ex) SHA, **MD5**, N-NASH, SNEFRU
- salt : 시스템에 저장되는 패스워드들은 Hash 또는 암호화 알고리즘의 결과 값으로 저장된다. 이때 암호공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값을 의미하는 것. 의미 그대로 소금친다는 뜻에서 Salt라고 불림
- MQTT 프로토콜 : Message Queuing Telemetry Transport. TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의 메시징 프로토콜
- SSO : Single Sign On. 여러 시스템 중 하나의 시스템에 인증을 성공하면 다른 시스템의 접근 권한도 모두 얻는 방식.
- OWASP(The Open Web Application Security Project)는 오픈소스 웹 애플리케이션 보안 프로젝트이다. 주로 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구함
- putnam - 레일리 - slim
- UWB - bluetooth - 피코넷
- 라우팅 프로토콜 링크상태 OSPF
- ISO/IEC 12119 테스트, 12207 프레임워크, 15504 SPICE
- SPICE 6단계. 불완전 수행 관리 확립 예측 최적화
- SAN : 광케이블 저장장치 단일화
- 정보보안의 3대 요소 : 기밀성, 무결성, 가용성
- 테일러링 : 주어진 대상에 딱 맞게 줄이거나 늘리는 것. 개별 과제의 특성에 맞게 딱 맞도록 방법론을 적용.
























